# Divan [![Build Status](https://travis-ci.org/garbados/divan.png)](https://travis-ci.org/garbados/divan) [![Coverage Status](https://coveralls.io/repos/garbados/divan/badge.png)](https://coveralls.io/r/garbados/divan)

[wiki]: http://en.wikipedia.org/wiki/Divan_(furniture\)
[wiki_img]: http://upload.wikimedia.org/wikipedia/commons/e/ea/FrancisLevettLiotard.jpg

An effortless Cloudant interface for Python.

Put on your favorite hookah, sit back on the [divan][wiki], and relax.

![What a Divan Looks Like][wiki_img]

## Install

    pip install divan
    
## Usage

All methods return response objects generated by Requests, if the request was successful. Else, the response object is attached to the thrown error. If a response has a bad status code, throw an error.

Classes attempt to map Cloudant's API to native Python datastructures: documents => dictionaries, arrays => iterators, 404 => KeyError, etc. 

Divan expose raw interactions -- HTTP requests, etc. -- through special methods, so we provide syntactical sugar without obscuring the underlying API. (builtins, such as __getitem__, should act as Pythonic shortcuts to those methods)

If CouchDB has a special endpoint for something, it's in Divan as a special method, so any special circumstances are taken care of automagically.

You can create objects explicitly or inherit them from objects higher in the DB heirarchy. So, you can create a `Database` object explicitly, or use `Connection.database` to inherit settings from the `Connection` object

## API

### Connection(uri, **kwargs)

#### Connection.info(**kwargs)

Return information about your CouchDB / Cloudant instance.

#### Connection.all_dbs(**kwargs)

List all databases.

#### Connection.database(name, **kwargs)

Create a `Database` object prefixed with this connection's URL.

#### Connection.session(**kwargs)

Get current user's authentication and authorization status.

#### Connection.logout(**kwargs)

De-authenticate the connection's cookie.

#### Connection.replicate(source, target, opts, **kwargs)

Begin a replication job.
`opts` contains replication options such as whether the replication
should create the target (`create_target`) or whether the replication
is continuous (`continuous`).

Note: unless continuous, will not return until the job is finished.

#### Connection.active_tasks(**kwargs)

List replication, compaction, and indexer tasks currently running.

#### Connection.login(username, password, **kwargs)

Authenticate the connection via cookie.

#### Connection.uuids(count, **kwargs)

Generate an arbitrary number of UUIDs.

### Database(uri, **kwargs)

Connection to a specific database

#### Database.all_docs(**kwargs)

Return an iterator over all documents in the database.

#### Database.view_cleanup(**kwargs)

#### Database.save_docs(docs, **kwargs)

Save many docs, all at once.

#### Database.revs_diff(revs, **kwargs)

#### Database.document(name, **kwargs)

Create a `Document` object from `name`.

#### Database.changes(**kwargs)

Gets a list of the changes made to the database. This can be used to monitor for update and modifications to the database for post processing or synchronization.

Automatically adjusts the request to handle the different response behavior of polling, longpolling, and continuous modes.

#### Database.missing_revs(revs, **kwargs)

### Document(uri, **kwargs)

#### Document.merge(docname, change, **kwargs)

Get document by `docname`, merge `changes`,
and then `PUT` the updated document back to the server

#### Document.view(method, function, **kwargs)

Create a `View` object by joining `method` and `function`.

#### Document.attachment(name, **kwargs)

Create an `Attachment` object from `name` and the settings
for the current database.

### View(uri, **kwargs)

Methods for design documents

### Attachment(uri, **kwargs)

Attachment methods for a single document


## Testing

Testing uses a live database, so you'll need to configure a `local_settings.py` file or set environment variables for `URI`, `DB_NAME`, `USER`, and `PASS`. Then:

    python setup.py test

## Documentation

The API reference is automatically generated from the docstrings of each class and its methods. To install Divan with the necessary extensions to build the docs, do this:

    pip install -e divan[docs]

Then, in Divan's root directory, do this:
  
    python docs

Note: docstrings are in [Markdown](http://daringfireball.net/projects/markdown/).